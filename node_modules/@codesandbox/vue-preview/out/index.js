Object.defineProperty(exports, "__esModule", { value: true });
exports.createPreviewConnection = void 0;
const WebSocket = require("ws");
function createPreviewConnection(options) {
    const wsList = [];
    let wss;
    let goToTemplateReq = 0;
    wss = new WebSocket.Server({ port: 56789 });
    wss.on('connection', ws => {
        wsList.push(ws);
        ws.on('message', msg => {
            const message = JSON.parse(msg.toString());
            if (message.command === 'goToTemplate') {
                const req = ++goToTemplateReq;
                const data = message.data;
                const token = {
                    get isCancelled() {
                        return req !== goToTemplateReq;
                    }
                };
                options.onGotoCode(data.fileName, data.range, token);
            }
            if (message.command === 'requestOpenFile') {
                const data = message.data;
                const url = options.getFileHref(data.fileName, data.range);
                ws.send(JSON.stringify({
                    command: 'openFile',
                    data: url,
                }));
            }
        });
    });
    return {
        stop,
        highlight,
        unhighlight,
    };
    function stop() {
        wss === null || wss === void 0 ? void 0 : wss.close();
        wsList.length = 0;
    }
    function highlight(fileName, ranges, isDirty) {
        const msg = {
            command: 'highlightSelections',
            data: {
                fileName,
                ranges,
                isDirty,
            },
        };
        for (const ws of wsList) {
            ws.send(JSON.stringify(msg));
        }
    }
    function unhighlight() {
        const msg = {
            command: 'highlightSelections',
            data: undefined,
        };
        for (const ws of wsList) {
            ws.send(JSON.stringify(msg));
        }
    }
}
exports.createPreviewConnection = createPreviewConnection;
//# sourceMappingURL=index.js.map